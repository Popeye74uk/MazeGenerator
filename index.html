<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Generator v0.23</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        :root{--color-background:#f8f9fa;--color-container-bg:#f8f9fa;--color-text-primary:#333;--color-text-secondary:#6c757d;--color-heading:#343a40;--color-grid-lines:#adb5bd;--color-grid-cell-bg:#fff;--color-button-disabled-bg:#6c757d;--color-spinner-track:#f3f3f3;--color-modal-bg:rgba(0,0,0,0.6);--color-modal-content-bg:white;--color-box-shadow:rgba(0,0,0,0.1);--color-box-shadow-hover:rgba(0,0,0,0.15);--color-primary:#007bff;--color-success:#28a745;--color-danger:#dc3545;--color-warning:#fd7e14;--color-info:#6f42c1;--color-pink:#d63384;--color-revealed-bg:rgba(40,167,69,0.3);--color-user-path-bg:rgba(0,123,255,0.3);--color-solved-path-bg:rgba(255,193,7,0.7);--color-start-bg:var(--color-success);--color-end-bg:var(--color-danger);--color-cursor-shadow:rgba(0,123,255,0.7); --color-board-bg: #121212;}
        body.dark-mode{--color-background:#121212;--color-container-bg:#1e1e1e;--color-text-primary:#e0e0e0;--color-text-secondary:#888;--color-heading:#f1f1f1;--color-grid-lines:#444;--color-grid-cell-bg:#2a2a2a;--color-button-disabled-bg:#555;--color-spinner-track:#444;--color-modal-bg:rgba(0,0,0,0.8);--color-modal-content-bg:#2c2c2c;--color-box-shadow:rgba(0,0,0,0.3);--color-box-shadow-hover:rgba(0,0,0,0.4);--color-revealed-bg:rgba(40,167,69,0.4);--color-user-path-bg:rgba(0,123,255,0.4);--color-solved-path-bg:rgba(255,193,7,0.6);--color-cursor-shadow:rgba(50,150,255,0.7); --color-board-bg: #000;}
        body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;font-size:16px;color:var(--color-text-primary);background-color:var(--color-background);padding:20px;margin:0;display:flex;justify-content:center;align-items:flex-start;min-height:100vh;transition:background-color .3s,color .3s}
        .container{width:100%;max-width:900px;margin:0 auto}
        .main-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:5px}
        .main-header h1{flex-grow:1;margin:0;padding:0 10px;text-align:center}
        .header-buttons{display:flex;gap:10px}
        .header-spacer{min-width:100px; flex-shrink:0}
        #puzzle-container{display:flex;margin-top:20px;justify-content:center}
        #grid-wrapper{position:relative;}
        #grid-wrapper:fullscreen{background-color:var(--color-board-bg);padding:20px;display:flex;justify-content:center;align-items:center}
        #grid{display:grid;background-color:transparent;font-family:"Courier New",Courier,monospace;font-weight:700;cursor:pointer; border: 1px solid var(--color-grid-lines);}
        #grid div{text-align:center;background-color:var(--color-grid-cell-bg);color:var(--color-text-primary);user-select:none;transition:background-color .2s, opacity .3s;position:relative;border-color:var(--color-grid-lines);box-sizing:border-box}
        #grid.blindfold-mode div:not(.visible-cell){background-color:var(--color-grid-lines);border-color:transparent}
        #grid div.wall-top{border-top:1px solid var(--color-grid-lines)}
        #grid div.wall-right{border-right:1px solid var(--color-grid-lines)}
        #grid div.wall-bottom{border-bottom:1px solid var(--color-grid-lines)}
        #grid div.wall-left{border-left:1px solid var(--color-grid-lines)}
        #grid div.start-cell, #grid div.start-cell.user-path {background-color:var(--color-start-bg)}
        #grid div.end-cell, #grid div.end-cell.user-path {background-color:var(--color-end-bg)}
        #grid div.end-cell.disabled{background-color:var(--color-text-secondary)}
        #grid div.solution-path{background-color:var(--color-revealed-bg)}
        #grid div.user-path{background-color:var(--color-user-path-bg)}
        #grid div.solved-path{background-color:var(--color-solved-path-bg)}
        #grid div.keyboard-cursor{box-shadow:inset 0 0 0 3px var(--color-cursor-shadow)}
        body.dark-mode .loader{background-color:var(--color-background)}
        .loader{position:absolute;top:0;left:0;right:0;bottom:0;background-color:var(--color-container-bg);display:flex;justify-content:center;align-items:center;flex-direction:column;gap:15px;z-index:10;font-size:1.1em;color:var(--color-text-secondary);border-radius:4px}
        .loader.hidden{opacity:0;pointer-events:none}
        #loader-time{font-size:.9em;font-style:italic;color:var(--color-text-secondary)}
        .spinner{border:4px solid var(--color-spinner-track);border-top:4px solid var(--color-primary);border-radius:50%;width:40px;height:40px;animation:spin 1s linear infinite}
        @keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
        #instructions-container{width:fit-content;margin:20px auto 0;text-align:center}
        #instructions-container h3{margin-top:0;color:var(--color-heading)}
        #instructions-list{list-style-position:inside;padding:0;margin:0 auto;display:inline-block;text-align:left}
        #instructions-list li{padding:4px 0;font-size:.95em;color:var(--color-text-primary)}
        .controls-grid{display:grid;grid-template-columns:1fr 1fr;gap:15px;max-width:415px;margin:25px auto 0}
        #custom-maze-options{max-width:415px;margin:25px auto 0; padding: 20px; border-radius: 8px; box-shadow: 0 4px 12px var(--color-box-shadow);}
        .option-group{display:grid;grid-template-columns:4.5em 1fr;align-items:center;gap:10px;margin-bottom:15px}
        .option-group label{font-weight:700;text-align:right}
        .option-group select{width:100%;padding:8px;font-size:.9em;box-sizing:border-box;border:1px solid var(--color-grid-lines);border-radius:5px;height:40px}
        .seed-container{max-width:415px;margin:20px auto -10px;display:flex;align-items:center;gap:10px}
        .seed-container label{font-weight:700;flex-shrink:0}
        .seed-group{display:flex;align-items:center;width:100%;height:40px}
        #seed-input{flex-grow:1;border:1px solid var(--color-grid-lines);border-radius:5px 0 0 5px;padding:8px;font-size:.9em;height:100%;box-sizing:border-box;background-color:var(--color-grid-cell-bg);color:var(--color-text-primary);border-right:none;}
        body.dark-mode #seed-input{background-color:#fff;color:#000}
        #seed-input:focus{outline:none}
        #play-seed-btn, #random-seed-btn{padding:0;width:40px;height:100%;line-height:38px;font-size:1.2em;background:var(--color-text-secondary);border:1px solid var(--color-text-secondary);color:#fff;cursor:pointer;flex-shrink:0;display:flex;justify-content:center;align-items:center}
        #play-seed-btn { border-radius: 0; border-right: none; background-color: var(--color-success); border-color: var(--color-success); }
        #random-seed-btn{border-radius:0 5px 5px 0}
        button{padding:12px 20px;font-size:1em;font-weight:700;cursor:pointer;color:#fff;border:none;border-radius:5px;transition:all .2s;box-shadow:0 2px 4px var(--color-box-shadow);width:100%;box-sizing:border-box}
        button:hover:not(:disabled){transform:translateY(-2px);box-shadow:0 4px 8px var(--color-box-shadow-hover)}
        button:disabled{background-color:var(--color-button-disabled-bg);cursor:not-allowed;opacity:.7}
        #new-random-maze-btn{background-color:var(--color-primary)}
        #custom-maze-btn { background-color: var(--color-warning); }
        #reveal-btn{background-color:var(--color-success)}
        #download-pdf-btn{background-color:var(--color-pink)}
        #make-book-btn{background-color:var(--color-danger); grid-column: 1 / -1;}
        #create-puzzle-btn{background-color:var(--color-success)}
        #cancel-custom-btn {background-color: var(--color-text-secondary);}
        #create-book-btn{background-color:var(--color-success)}
        #cancel-btn,#cancel-book-options-btn{background-color:var(--color-text-secondary)}
        #cancel-btn{min-width:120px;width:auto}
        #generate-book-controls{display:none}
        .book-options-grid{display:grid;grid-template-columns:auto 1fr;justify-content:center;align-items:center;gap:10px 15px;margin:15px auto 0;max-width:415px}
        .book-options-grid label{text-align:right}
        #book-checkbox-options{display:flex;gap:20px;align-items:center;justify-content:flex-start}
        #book-checkbox-options label{user-select:none;cursor:pointer}
        #status-container, #game-mode-status {text-align:center;margin-top:15px;font-style:italic;min-height:20px;color:var(--color-text-secondary)}
        #version-info{text-align:center;margin-top:20px;font-size:.8em;color:var(--color-grid-lines)}
        #completion-modal{position:fixed;top:0;left:0;right:0;bottom:0;background-color:var(--color-modal-bg);display:flex;justify-content:center;align-items:center;z-index:20;opacity:0;pointer-events:none;transition:opacity .3s ease-in-out}
        #completion-modal.visible{opacity:1;pointer-events:auto}
        .modal-content{background-color:var(--color-modal-content-bg);padding:40px;border-radius:10px;text-align:center;box-shadow:0 5px 15px var(--color-box-shadow);transform:scale(.9);transition:transform .3s ease-in-out}
        #completion-modal.visible .modal-content{transform:scale(1)}
        .modal-content h2{font-size:2.5em;margin-top:0;margin-bottom:20px;color:var(--color-success)}
        .modal-content button{min-width:150px;background-color:var(--color-primary)}
        #completion-details{margin-bottom:25px;font-size:1.1em;color:var(--color-text-primary)}
        #completion-details p{margin:5px 0}
        #new-best-time{color:var(--color-warning);font-weight:700}
        #grid-wrapper,#instructions-container{visibility:hidden}
        #fullscreen-btn, #theme-toggle-btn{background:0 0;border:2px solid var(--color-text-secondary);color:var(--color-text-secondary);width:44px;height:44px;padding:0;border-radius:50%;display:flex;justify-content:center;align-items:center;overflow:hidden;box-shadow:none;flex-shrink:0}
        #fullscreen-btn:hover, #theme-toggle-btn:hover{border-color:var(--color-text-primary);color:var(--color-text-primary);transform:none;box-shadow:none}
        #fullscreen-btn svg, #theme-toggle-btn svg{width:24px;height:24px;fill:currentColor;transition:transform .3s ease-in-out}
        .icon-sun,.icon-moon{display:none}
        body.dark-mode .icon-sun{display:block}
        body:not(.dark-mode) .icon-moon{display:block}
        @media print{@page{size:A4;margin:.5in}body{background-color:#fff;font-size:12pt;margin:0;padding:0}.container{width:100%;margin:0;padding:0;box-shadow:none}.main-header,.seed-container,#custom-maze-options,.controls-grid,#generate-book-controls,#status-container,#game-mode-status,#version-info{display:none}#grid-wrapper{border:2px solid #333}#grid{border:none}#instructions-container{margin-top:15px}}
        @media (max-width:768px){.book-options-grid{grid-template-columns:1fr}.book-options-grid label{text-align:left;margin-left:5px}}
        @media (max-width:480px){.main-header h1{font-size:1.5em}#book-checkbox-options{flex-direction:column;align-items:flex-start;gap:12px}.modal-content h2{font-size:2em}.controls-grid{grid-template-columns:1fr}}
    </style>
    <style id="dynamic-grid-styles"></style>
</head>
<body>
    <div class="container">
        <header class="main-header">
            <div class="header-spacer"></div>
            <h1>Maze Generator</h1>
            <div class="header-buttons">
                 <button id="fullscreen-btn" title="Toggle Fullscreen (F)">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" style="width:22px;height:22px;"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
                </button>
                <button id="theme-toggle-btn" title="Toggle theme">
                    <svg class="icon-sun" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zM2 13h2c.55 0 1-.45 1-1s-.45-1-1-1H2c-.55 0-1 .45-1 1s.45 1 1 1zm18 0h2c.55 0 1-.45 1-1s-.45-1-1-1h-2c-.55 0-1 .45-1 1s.45 1 1 1zM11 2v2c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1s-1 .45-1 1zm0 18v2c0 .55.45 1 1 1s1-.45 1-1v-2c0-.55-.45-1-1-1s-1 .45-1 1zM5.64 5.64c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41-.39-.39-1.02-.39-1.41 0-.39.39-.39 1.02 0 1.41zm12.73 12.73c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41-.39-.39-1.02-.39-1.41 0-.39.39-.39 1.02 0 1.41zM5.64 18.36c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41-.39-.39-1.02-.39-1.41 0zM18.36 5.64c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41-.39-.38-1.03-.38-1.41 0z"/></svg>
                    <svg class="icon-moon" xmlns="http://www.w3.org/2000/svg" enable-background="new 0 0 24 24" viewBox="0 0 24 24"><path d="M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.11-1.36c-0.98,1.37-2.58,2.26-4.39,2.26 c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.39C12.92,3.04,12.46,3,12,3z"/></svg>
                </button>
            </div>
        </header>

        <div id="puzzle-container">
            <div id="grid-wrapper">
                <div id="grid"></div>
                <div id="loader" class="loader">
                    <div class="spinner"></div>
                    <span id="loader-text"></span>
                    <span id="loader-time"></span>
                    <button id="cancel-btn" onclick="cancelBookGeneration()">Cancel</button>
                </div>
            </div>
        </div>
        <div id="instructions-container">
            <h3 id="instructions-title">Instructions</h3>
            <ul id="instructions-list"></ul>
        </div>
        
        <div class="seed-container">
            <label for="seed-input">Seed:</label>
            <div class="seed-group">
                <input type="text" id="seed-input" placeholder="Any text for repeatable maze">
                <button id="play-seed-btn" title="Generate from Seed">▶</button>
                <button id="random-seed-btn" title="Random Seed">🎲</button>
            </div>
        </div>

        <div class="controls-grid" id="main-controls">
            <button id="new-random-maze-btn">New Random Maze</button>
            <button id="custom-maze-btn">Custom Maze</button>
            <button id="reveal-btn">Reveal Solution</button>
            <button id="download-pdf-btn">Download as PDF</button>
            <button id="make-book-btn">Make Book</button>
        </div>

        <div id="custom-maze-options" style="display: none;">
            <h3 style="text-align: center; margin-top: 0;">Custom Maze Options</h3>
            <div class="option-group">
                <label for="grid-size-select">Size:</label>
                <select id="grid-size-select">
                    <option value="15">15x15</option>
                    <option value="20" selected>20x20</option>
                    <option value="25">25x25</option>
                    <option value="50">50x50</option>
                    <option value="75">75x75</option>
                    <option value="100">100x100</option>
                </select>
            </div>
            <div class="option-group">
                <label for="maze-type-select">Maze:</label>
                <select id="maze-type-select">
                    <option value="binary">Binary Tree (Easy)</option>
                    <option value="prim">Prim's Algorithm</option>
                    <option value="kruskal">Kruskal's Algorithm</option>
                    <option value="backtracker" selected>DFS Backtracker (Hard)</option>
                    <option value="wilsons">Wilson's Algorithm (Expert)</option>
                </select>
            </div>
             <div class="option-group">
                <label for="game-mode-select">Mode:</label>
                <select id="game-mode-select">
                    <option value="default">Start to End</option>
                    <option value="longest_path">Longest Path</option>
                    <option value="blindfold">Blindfold</option>
                </select>
            </div>
            <div class="controls-grid" style="margin-top: 10px;">
                <button id="create-puzzle-btn">Create Puzzle</button>
                <button id="cancel-custom-btn">Cancel</button>
            </div>
        </div>

        <div id="generate-book-controls">
            <h3>Make a Book</h3>
            <div class="book-options-grid">
                <label for="book-title-input">Book Title:</label>
                <input type="text" id="book-title-input" placeholder="e.g., My Awesome Maze Book">
                
                <label for="book-subtitle-input">Subtitle:</label>
                <input type="text" id="book-subtitle-input" placeholder="e.g., By Alex Doe">

                <label for="puzzle-count-input">Mazes:</label>
                <input type="number" id="puzzle-count-input" value="10" min="1" max="100" style="width: 70px;">
                
                <label>Options:</label>
                <div id="book-checkbox-options">
                    <label for="answer-key-checkbox"><input type="checkbox" id="answer-key-checkbox" checked> Maze Solutions</label>
                    <label for="page-numbers-checkbox"><input type="checkbox" id="page-numbers-checkbox" checked> Page Numbers</label>
                </div>
            </div>
            <div class="controls-grid">
                <button id="create-book-btn">Create Book</button>
                <button id="cancel-book-options-btn">Cancel</button>
            </div>
        </div>

        <div id="status-container"><p id="source-status"></p></div>
        <div id="game-mode-status"></div>
        <div id="version-info">v0.22</div>
    </div>

    <div id="completion-modal" onclick="hideCompletionModal()">
        <div class="modal-content">
            <h2>You Solved It!</h2>
            <div id="completion-details">
                <p id="your-time"></p>
                <p id="best-time"></p>
                <p id="new-best-time"></p>
            </div>
            <button id="play-again-btn">Play Again?</button>
        </div>
    </div>
    
    <script>
        // --- GLOBAL VARIABLES ---
        let gridSize = 20;
        let currentGridState = [], solutionPath = [];
        let isGeneratingBook = false, isAnimating = false;
        let animationToken = 0; // Used to cancel running animations
        let debounceTimeout;
        let startTime, puzzleConfigKey, rng;
        let isDrawing = false, userPath = [], startCoords, endCoords;
        let gameMode = 'default';

        // --- DOM ELEMENT CACHING ---
        const ui = {
            grid: document.getElementById('grid'),
            gridWrapper: document.getElementById('grid-wrapper'),
            puzzleContainer: document.getElementById('puzzle-container'),
            revealBtn: document.getElementById('reveal-btn'),
            status: document.getElementById('source-status'),
            gameModeStatus: document.getElementById('game-mode-status'),
            loader: document.getElementById('loader'),
            loaderText: document.getElementById('loader-text'),
            gridSizeSelect: document.getElementById('grid-size-select'),
            mazeTypeSelect: document.getElementById('maze-type-select'),
            gameModeSelect: document.getElementById('game-mode-select'),
            seedInput: document.getElementById('seed-input'),
            randomSeedBtn: document.getElementById('random-seed-btn'),
            playSeedBtn: document.getElementById('play-seed-btn'),
            mainControls: document.getElementById('main-controls'),
            generateBookControls: document.getElementById('generate-book-controls'),
            customMazeOptions: document.getElementById('custom-maze-options'),
            completionModal: document.getElementById('completion-modal'),
            newRandomMazeBtn: document.getElementById('new-random-maze-btn'),
            customMazeBtn: document.getElementById('custom-maze-btn'),
            createPuzzleBtn: document.getElementById('create-puzzle-btn'),
            cancelCustomBtn: document.getElementById('cancel-custom-btn'),
            downloadPdfBtn: document.getElementById('download-pdf-btn'),
            makeBookBtn: document.getElementById('make-book-btn'),
            createBookBtn: document.getElementById('create-book-btn'),
            cancelBookOptionsBtn: document.getElementById('cancel-book-options-btn'),
            playAgainBtn: document.getElementById('play-again-btn'),
            instructionsTitle: document.getElementById('instructions-title'),
            instructionsList: document.getElementById('instructions-list'),
            fullscreenBtn: document.getElementById('fullscreen-btn')
        };
        
        function cyrb128(str) { let h1=1779033703,h2=3144134277,h3=1013904242,h4=2773480762; for (let i=0,k;i<str.length;i++){k=str.charCodeAt(i);h1=h2^Math.imul(h1^k,597399067);h2=h3^Math.imul(h2^k,2869860233);h3=h4^Math.imul(h3^k,951274213);h4=h1^Math.imul(h4^k,2716044179)} h1=Math.imul(h3^(h1>>>18),597399067);h2=Math.imul(h4^(h2>>>22),2869860233);h3=Math.imul(h1^(h3>>>17),951274213);h4=Math.imul(h2^(h4>>>19),2716044179); return(h1^h2^h3^h4)>>>0 }
        function mulberry32(a){ return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296} }
        
        function triggerGeneratePuzzle() { clearTimeout(debounceTimeout); debounceTimeout = setTimeout(() => generatePuzzle(), 20); }

        async function generatePuzzle(isForBook = false) {
            animationToken++; 
            isAnimating = false;

            gridSize = parseInt(ui.gridSizeSelect.value, 10);
            const mazeType = ui.mazeTypeSelect.value;
            gameMode = ui.gameModeSelect.value;
            let seed = ui.seedInput.value.trim() || Date.now().toString();
            if (isForBook && ui.seedInput.value.trim() === '') seed += Math.random();
            if (!isForBook) ui.seedInput.value = seed;
            rng = mulberry32(cyrb128(seed));

            const loaderMessage = gridSize >= 75 ? "Generating large maze..." : "Generating Maze...";
            if (!isForBook) { setUiLoading(true, loaderMessage); ui.completionModal.classList.remove('visible'); }
            
            userPath = []; solutionPath = []; startTime = null; ui.revealBtn.disabled = false;
            ui.gameModeStatus.textContent = '';
            
            await new Promise(resolve => setTimeout(resolve, 30));

            try {
                let mazeGrid;
                
                switch(mazeType) {
                    case 'prim': mazeGrid = generateMazePrim(gridSize, gridSize); break;
                    case 'binary': mazeGrid = generateMazeBinaryTree(gridSize, gridSize); break;
                    case 'kruskal': mazeGrid = generateMazeKruskal(gridSize, gridSize); break;
                    case 'wilsons': mazeGrid = generateMazeWilsons(gridSize, gridSize); break;
                    default: mazeGrid = generateMazeRecursiveBacktracker(gridSize, gridSize); break;
                }
                
                let path;

                if (gameMode === 'longest_path') {
                    const longestPathData = findLongestPathEndpoints(mazeGrid);
                    startCoords = longestPathData.start;
                    endCoords = longestPathData.end;
                    path = longestPathData.path;
                } else {
                    startCoords = { x: 0, y: 0 };
                    endCoords = { x: gridSize - 1, y: gridSize - 1 };
                    path = findSolutionPath(mazeGrid, startCoords, endCoords);
                }
                
                userPath.push(startCoords);
                currentGridState = mazeGrid;
                solutionPath = path;

                if (!isForBook) {
                    puzzleConfigKey = `${gridSize}-${mazeType}-${seed}-${gameMode}`;
                    ui.status.textContent = `Type: ${ui.mazeTypeSelect.options[ui.mazeTypeSelect.selectedIndex].text}`;
                    updateInstructions();
                    updateGridDisplay(true);
                    document.getElementById('grid-wrapper').style.visibility = 'visible';
                    document.getElementById('instructions-container').style.visibility = 'visible'; 
                    startTime = Date.now();
                }

                const puzzleData = { grid: mazeGrid, solution: path, title: `Maze ${gridSize}x${gridSize}`, start: startCoords, end: endCoords };
                puzzleData.metadata = {
                    size: `${gridSize}x${gridSize}`,
                    type: ui.mazeTypeSelect.options[ui.mazeTypeSelect.selectedIndex].text,
                    mode: ui.gameModeSelect.options[ui.gameModeSelect.selectedIndex].text,
                    modeId: gameMode,
                    seed: seed
                };
                return puzzleData;

            } catch (error) {
                if (error.message !== "Animation cancelled") { ui.status.textContent = `Error: ${error.message}`; console.error(error); }
                return null;
            } finally {
                if (!isForBook) { setUiLoading(false); }
            }
        }
        
        function createEmptyGrid(width, height) { return Array(height).fill(null).map((_, y) => Array(width).fill(null).map((_, x) => ({ x, y, walls: [true, true, true, true], visited: false }))); }
        function getNeighbors(cell, grid, allDirs = false) { const { x, y } = cell; const neighbors = []; const directions = [{x:0, y:-1}, {x:1, y:0}, {x:0, y:1}, {x:-1, y:0}]; for (const dir of directions) { const nX = x + dir.x, nY = y + dir.y; if (nX >= 0 && nX < grid[0].length && nY >= 0 && nY < grid.length) { const neighbor = grid[nY][nX]; if(allDirs || !neighbor.visited) neighbors.push(neighbor); } } return neighbors; }
        function removeWall(a, b) { const dX = a.x - b.x, dY = a.y - b.y; if (dX === 1) { a.walls[3] = false; b.walls[1] = false; } else if (dX === -1) { a.walls[1] = false; b.walls[3] = false; } if (dY === 1) { a.walls[0] = false; b.walls[2] = false; } else if (dY === -1) { a.walls[2] = false; b.walls[0] = false; } }
        function generateMazeRecursiveBacktracker(w,h){const g=createEmptyGrid(w,h);const s=[g[0][0]];g[0][0].visited=!0;while(s.length>0){const c=s.pop();const n=getNeighbors(c,g);if(n.length>0){s.push(c);const N=n[Math.floor(rng()*n.length)];removeWall(c,N);N.visited=!0;s.push(N)}}return g}
        function generateMazePrim(w,h){const g=createEmptyGrid(w,h);const f=[];const sX=Math.floor(rng()*w),sY=Math.floor(rng()*h);g[sY][sX].visited=!0;getNeighbors(g[sY][sX],g,!0).forEach(n=>f.push(n));while(f.length>0){const fI=Math.floor(rng()*f.length);const c=f.splice(fI,1)[0];const iN=getNeighbors(c,g,!0).filter(n=>n.visited);if(iN.length>0){const N=iN[Math.floor(rng()*iN.length)];removeWall(c,N);c.visited=!0;getNeighbors(c,g,!0).filter(n=>!n.visited).forEach(n=>{if(!f.some(fr=>fr.x===n.x&&fr.y===n.y))f.push(n)})}}return g}
        function generateMazeBinaryTree(w,h){const g=createEmptyGrid(w,h);for(let y=0;y<h;y++){for(let x=0;x<w;x++){const c=g[y][x];const n=[];if(y>0)n.push(g[y-1][x]);if(x>0)n.push(g[y][x-1]);if(n.length>0){const N=n[Math.floor(rng()*n.length)];removeWall(c,N)}}}return g}
        function generateMazeKruskal(w,h){const g=createEmptyGrid(w,h);const e=[];const s=[];for(let y=0;y<h;y++){for(let x=0;x<w;x++){s[y*w+x]=y*w+x;if(y>0)e.push({c1:g[y][x],c2:g[y-1][x]});if(x>0)e.push({c1:g[y][x],c2:g[y][x-1]})}}for(let i=e.length-1;i>0;i--){const j=Math.floor(rng()*(i+1));[e[i],e[j]]=[e[j],e[i]]}const find=i=>s[i]===i?i:(s[i]=find(s[i]));const union=(i,j)=>{const rI=find(i),rJ=find(j);if(rI!==rJ)s[rI]=rJ};for(const edge of e){const{c1,c2}=edge;const n1=c1.y*w+c1.x,n2=c2.y*w+c2.x;if(find(n1)!==find(n2)){removeWall(c1,c2);union(n1,n2)}}return g}
        function generateMazeWilsons(w,h){const g=createEmptyGrid(w,h);const u=[];g.forEach(r=>r.forEach(c=>u.push(c)));const fC=u.splice(Math.floor(rng()*u.length),1)[0];fC.visited=!0;while(u.length>0){let c=u[Math.floor(rng()*u.length)];let p=[c];while(!c.visited){const n=getNeighbors(c,g,!0);c=n[Math.floor(rng()*n.length)];const pI=p.findIndex(cell=>cell.x===c.x&&cell.y===c.y);if(pI!==-1){p.splice(pI+1)}else{p.push(c)}}for(let i=0;i<p.length-1;i++){removeWall(p[i],p[i+1]);p[i].visited=!0;const uI=u.findIndex(cell=>cell.x===p[i].x&&cell.y===p[i].y);if(uI!==-1)u.splice(uI,1)}}return g}
        
        function findSolutionPath(grid, start, end) { const queue = [[start]]; const visited = new Set([`${start.x},${start.y}`]); while(queue.length > 0) { const path = queue.shift(); const { x, y } = path[path.length - 1]; if (x === end.x && y === end.y) return path; const cell = grid[y][x]; const directions = [{x:0, y:-1}, {x:1, y:0}, {x:0, y:1}, {x:-1, y:0}]; for (let i = 0; i < directions.length; i++) { if (!cell.walls[i]) { const nX = x + directions[i].x, nY = y + directions[i].y; const key = `${nX},${nY}`; if (!visited.has(key)) { visited.add(key); queue.push([...path, {x: nX, y: nY}]); } } } } return []; }
        function findAllDistances(grid, startCell) { const queue = [[startCell]]; const visited = new Set([`${startCell.x},${startCell.y}`]); let longestPath = [startCell]; while (queue.length > 0) { const path = queue.shift(); const currentCell = path[path.length - 1]; if (path.length > longestPath.length) { longestPath = path; } const cell = grid[currentCell.y][currentCell.x]; const directions = [{ x: 0, y: -1 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: -1, y: 0 }]; for (let i = 0; i < directions.length; i++) { if (!cell.walls[i]) { const nX = currentCell.x + directions[i].x, nY = currentCell.y + directions[i].y; const key = `${nX},${nY}`; if (!visited.has(key)) { visited.add(key); const newPath = [...path, { x: nX, y: nY }]; queue.push(newPath); } } } } return { farthestCell: longestPath[longestPath.length - 1], path: longestPath }; }
        function findLongestPathEndpoints(grid) { const firstPass = findAllDistances(grid, grid[0][0]); const secondPass = findAllDistances(grid, firstPass.farthestCell); return { start: firstPass.farthestCell, end: secondPass.farthestCell, path: secondPass.path }; }
        
        function getInstructionsText(modeId) {
            switch (modeId) {
                case 'longest_path': return 'Use the Arrow Keys to find the longest possible path between the two endpoints.\nOr, click and drag from the start (green) to the end (red).';
                case 'blindfold': return 'Use the Arrow Keys to navigate. Your vision is limited to the immediate area.\nTry to find the end (red) with only a limited view of the maze.';
                default: return 'Use the Arrow Keys to move from the start (green) to the end (red).\nOr, click and drag from the green square to the red square.';
            }
        }

        function updateInstructions() {
            const selectedOption = ui.gameModeSelect.options[ui.gameModeSelect.selectedIndex];
            ui.instructionsTitle.textContent = `Instructions - ${selectedOption.text}`;
            ui.instructionsList.innerHTML = getInstructionsText(gameMode).split('\n').map(line => `<li>${line}</li>`).join('');
        }

        function setUiLoading(isLoading, message = '') { document.querySelectorAll('button, select, input').forEach(b=>b.disabled=isLoading); ui.loader.classList.toggle('hidden',!isLoading); ui.loaderText.textContent=message; document.getElementById('cancel-btn').style.display='none'; }
        
        function updateCellDisplay(cell) { const { x, y, walls } = cell; if (!cell.domElement) cell.domElement = ui.grid.querySelector(`[data-x='${x}'][data-y='${y}']`); if (!cell.domElement) return; cell.domElement.className = ''; if (walls[0]) cell.domElement.classList.add('wall-top'); if (walls[1]) cell.domElement.classList.add('wall-right'); if (walls[2]) cell.domElement.classList.add('wall-bottom'); if (walls[3]) cell.domElement.classList.add('wall-left'); if (x === startCoords?.x && y === startCoords?.y) cell.domElement.classList.add('start-cell'); if (x === endCoords?.x && y === endCoords?.y) cell.domElement.classList.add('end-cell'); }
        
        function updateGridDisplay(forceRedraw = false) {
            const isFullscreen = !!document.fullscreenElement;
            let containerSize;
            if (isFullscreen) {
                containerSize = Math.min(window.innerWidth, window.innerHeight) - 40;
            } else {
                containerSize = Math.min(ui.puzzleContainer.clientWidth, 800);
            }
            
            let cellSize = Math.floor(containerSize / gridSize);
            cellSize = Math.max(2, cellSize);
            
            ui.grid.style.gridTemplateColumns = `repeat(${gridSize}, ${cellSize}px)`;
            ui.grid.style.gridTemplateRows = `repeat(${gridSize}, ${cellSize}px)`;

            const wallWidth = Math.max(1, Math.floor(cellSize / 12));
            document.getElementById('dynamic-grid-styles').innerHTML = `
                #grid div.wall-top{border-top-width:${wallWidth}px;border-top-style:solid}
                #grid div.wall-right{border-right-width:${wallWidth}px;border-right-style:solid}
                #grid div.wall-bottom{border-bottom-width:${wallWidth}px;border-bottom-style:solid}
                #grid div.wall-left{border-left-width:${wallWidth}px;border-left-style:solid}
                #grid div.keyboard-cursor{box-shadow:inset 0 0 0 ${Math.max(2,wallWidth+1)}px var(--color-cursor-shadow)}`;

            if (forceRedraw) {
                ui.grid.innerHTML = '';
                if (currentGridState.length > 0) {
                    ui.grid.classList.toggle('blindfold-mode', gameMode === 'blindfold');
                    for (let y = 0; y < gridSize; y++) {
                        for (let x = 0; x < gridSize; x++) {
                            const c = document.createElement('div');
                            c.dataset.x = x; c.dataset.y = y;
                            const cD = currentGridState[y][x];
                            cD.domElement = c;
                            updateCellDisplay(cD);
                            ui.grid.appendChild(c);
                        }
                    }
                }
            }
            redrawUserPath();
        }
        
        function redrawUserPath() { document.querySelectorAll('#grid div.user-path, #grid div.keyboard-cursor, #grid div.solved-path, #grid div.visible-cell').forEach(c => { c.classList.remove('user-path', 'keyboard-cursor', 'solved-path', 'visible-cell') }); if (gameMode === 'blindfold' && userPath.length > 0) { const lastPos = userPath[userPath.length - 1]; const visibilityRadius = 2; for (let y = -visibilityRadius; y <= visibilityRadius; y++) { for (let x = -visibilityRadius; x <= visibilityRadius; x++) { if (Math.abs(x) + Math.abs(y) <= visibilityRadius) { const cell = ui.grid.querySelector(`[data-x='${lastPos.x + x}'][data-y='${lastPos.y + y}']`); if (cell) cell.classList.add('visible-cell'); } } } } userPath.forEach(p => { const cell = ui.grid.querySelector(`[data-x='${p.x}'][data-y='${p.y}']`); if (cell) { cell.classList.add('user-path'); if (gameMode === 'blindfold') cell.classList.add('visible-cell'); } }); if (userPath.length > 0) { const lastPos = userPath[userPath.length - 1]; const cursorCell = ui.grid.querySelector(`[data-x='${lastPos.x}'][data-y='${lastPos.y}']`); if (cursorCell) cursorCell.classList.add('keyboard-cursor'); } }
        function revealSolution() { if(solutionPath.length === 0 || isAnimating) return; isAnimating = true; ui.revealBtn.disabled = true; let i = 0; const currentToken = ++animationToken; if(gameMode === 'blindfold') ui.grid.classList.remove('blindfold-mode'); function animate() { if (i < solutionPath.length && currentToken === animationToken) { const pos = solutionPath[i]; const cell = ui.grid.querySelector(`[data-x='${pos.x}'][data-y='${pos.y}']`); if(cell) cell.classList.add('solution-path'); i++; requestAnimationFrame(animate); } else { isAnimating = false; } } animate(); }
        
        function setUIView(view) {
            ui.mainControls.style.display = 'none';
            ui.customMazeOptions.style.display = 'none';
            ui.generateBookControls.style.display = 'none';
            if (view === 'custom') ui.customMazeOptions.style.display = 'block';
            else if (view === 'book') ui.generateBookControls.style.display = 'block';
            else ui.mainControls.style.display = 'grid';
        }
        
        function downloadPdf() {
            if (currentGridState.length === 0) { alert("Please generate a maze first."); return; }
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
            const puzzleData = { 
                grid: currentGridState, 
                solution: solutionPath, 
                title: 'Maze', 
                start: startCoords, 
                end: endCoords, 
                metadata: {
                    size: `${gridSize}x${gridSize}`,
                    type: ui.mazeTypeSelect.options[ui.mazeTypeSelect.selectedIndex].text,
                    mode: ui.gameModeSelect.options[ui.gameModeSelect.selectedIndex].text,
                    modeId: gameMode,
                    seed: ui.seedInput.value
                }
            };
            drawMazeOnPdfPage(doc, puzzleData, false, null, false);
            doc.save(`Maze-${gridSize}x${gridSize}-${ui.mazeTypeSelect.value}.pdf`);
        }

        async function downloadBook() {
            const puzzleCount = parseInt(document.getElementById('puzzle-count-input').value, 10);
            if (isNaN(puzzleCount) || puzzleCount < 1 || puzzleCount > 100) { alert("Please enter a number between 1 and 100."); return; }
            const includeSolutions = document.getElementById('answer-key-checkbox').checked;
            const includePageNums = document.getElementById('page-numbers-checkbox').checked;
            const bookTitle = document.getElementById('book-title-input').value.trim();
            const bookSubtitle = document.getElementById('book-subtitle-input').value.trim();
            ui.grid.innerHTML = ''; document.getElementById('instructions-container').style.visibility = 'hidden';
            isGeneratingBook = true;
            setUiLoading(true, "Preparing Book...");
            ui.loader.scrollIntoView({ behavior: 'smooth', block: 'center' });
            document.getElementById('cancel-btn').style.display = 'block';
            document.getElementById('cancel-btn').disabled = false;
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
            doc.deletePage(1);
            const allPuzzleData = [];
            try {
                if (bookTitle) {
                    doc.addPage();
                    const pageWidth = doc.internal.pageSize.getWidth(), pageHeight = doc.internal.pageSize.getHeight();
                    doc.setFont('helvetica', 'bold').setFontSize(30).text(bookTitle, pageWidth / 2, pageHeight / 2 - 10, { align: 'center' });
                    if (bookSubtitle) doc.setFont('helvetica', 'normal').setFontSize(16).text(bookSubtitle, pageWidth / 2, pageHeight / 2 + 5, { align: 'center' });
                }
                for (let i = 1; i <= puzzleCount; i++) {
                    if (!isGeneratingBook) { throw new Error("Cancelled"); }
                    ui.loaderText.textContent = `Generating Maze ${i} of ${puzzleCount}...`;
                    const pD = await generatePuzzle(true);
                    if (!pD) continue;
                    pD.title = `Maze ${i}`;
                    allPuzzleData.push(pD);
                    doc.addPage();
                    drawMazeOnPdfPage(doc, pD, false, i, includePageNums);
                }
                if (includeSolutions && allPuzzleData.length > 0) {
                    ui.loaderText.textContent = "Generating Maze Solutions...";
                    await new Promise(r => setTimeout(r, 50));
                    drawMazeSolutions(doc, allPuzzleData);
                }
                const safeTitle = (bookTitle.replace(/[^a-zA-Z0-9]/g, '-') || `Maze-Book-${puzzleCount}-Mazes`).substring(0, 50);
                doc.save(`${safeTitle}.pdf`);
                ui.status.textContent = "Book successfully generated!";
            } catch (e) {
                if (e.message === "Cancelled") ui.status.textContent = "Book generation cancelled.";
                else ui.status.textContent = `Error: ${e.message}`;
            } finally {
                isGeneratingBook = false;
                setUiLoading(false);
                setUIView('default');
                triggerGeneratePuzzle();
            }
        }

        function cancelBookGeneration() { isGeneratingBook = false; }
        
        function drawMazeOnPdfPage(d, pD, sS, pN, iPN) {
            const { grid: g, solution: s, title: t, start: pdfStart, end: pdfEnd, metadata } = pD;
            const pW = d.internal.pageSize.getWidth(), pH = d.internal.pageSize.getHeight();
            const margin = 15, contentWidth = pW - 2 * margin;

            d.setDrawColor(0, 0, 0);
            d.setLineWidth(0.5);
            d.roundedRect(margin - 5, margin - 5, contentWidth + 10, pH - (2 * margin) + 2, 3, 3, 'S');

            let cY = margin + 5;
            d.setFont('helvetica', 'bold').setFontSize(18);
            d.text(t, pW / 2, cY, { align: 'center' });
            cY += 15;

            const mazeSize = 170, cellSize = mazeSize / g.length;
            const startX = (pW - mazeSize) / 2, startY = cY;
            if (sS) { d.setFillColor(255, 193, 7); s.forEach(p => d.rect(startX + p.x * cellSize, startY + p.y * cellSize, cellSize, cellSize, 'F')); }
            d.setFillColor(40, 167, 69).rect(startX + pdfStart.x * cellSize, startY + pdfStart.y * cellSize, cellSize, cellSize, 'F');
            d.setFillColor(220, 53, 69).rect(startX + pdfEnd.x * cellSize, startY + pdfEnd.y * cellSize, cellSize, cellSize, 'F');
            d.setDrawColor(0, 0, 0).setLineWidth(0.5);
            for (let y = 0; y < g.length; y++) { for (let x = 0; x < g.length; x++) { const c = g[y][x], cX = startX + x * cellSize, cY = startY + y * cellSize; if (c.walls[0]) d.line(cX, cY, cX + cellSize, cY); if (c.walls[1]) d.line(cX + cellSize, cY, cX + cellSize, cY + cellSize); if (c.walls[2]) d.line(cX, cY + cellSize, cX + cellSize, cY + cellSize); if (c.walls[3]) d.line(cX, cY, cX, cY + cellSize); } }
            cY = startY + mazeSize + 10;
            
            if (metadata) {
                d.setFont('helvetica', 'bold').setFontSize(10);
                d.text('Puzzle Details', pW / 2, cY, { align: 'center' });
                cY += 6;

                d.setFont('helvetica', 'normal').setFontSize(9);
                const metadataLines = [ `Size: ${metadata.size}`, `Type: ${metadata.type}`, `Mode: ${metadata.mode}`, `Seed: ${metadata.seed}` ];
                d.text(metadataLines, pW/2, cY, {align: 'center'});
            }

            if (iPN && pN) { d.setFont('helvetica', 'normal').setFontSize(8).text(String(pN), pW / 2, pH - margin + 8, { align: 'center' }); }
        }
        
        function drawMazeSolutions(d,aPD){d.addPage();const pW=d.internal.pageSize.getWidth(),pH=d.internal.pageSize.getHeight(),m=15;d.setFont('helvetica','bold').setFontSize(20).text("Maze Solutions",pW/2,m,{align:'center'});const pPP=6,cols=2,rows=3;const bW=(pW-m*2)/cols,bH=(pH-m*2-10)/rows;aPD.forEach((pD,idx)=>{if(idx>0&&idx%pPP===0){d.addPage();d.setFont('helvetica','bold').setFontSize(20).text("Maze Solutions",pW/2,m,{align:'center'})}const i=idx%pPP;const col=i%cols,row=Math.floor(i/cols);const sBX=m+col*bW,sBY=m+10+row*bH;d.setFont('helvetica','bold').setFontSize(10).text(pD.title,sBX+bW/2,sBY+8,{align:'center'});const mS=Math.min(bW-10,bH-20),cG=pD.grid.length,cS=mS/cG;const sX=sBX+(bW-mS)/2,sY=sBY+12;d.setFillColor(255,193,7);pD.solution.forEach(p=>d.rect(sX+p.x*cS,sY+p.y*cS,cS,cS,'F'));d.setDrawColor(0).setLineWidth(.2);for(let y=0;y<cG;y++){for(let x=0;x<cG;x++){const c=pD.grid[y][x],cX=sX+x*cS,cY=sY+y*cS;if(c.walls[0])d.line(cX,cY,cX+cS,cY);if(c.walls[1])d.line(cX+cS,cY,cX+cS,cY+cS);if(c.walls[2])d.line(cX,cY+cS,cX+cS,cY+cS);if(c.walls[3])d.line(cX,cY,cX,cY+cS)}}})}
        
        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                ui.gridWrapper.requestFullscreen().catch(err => {
                    alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                });
            } else {
                document.exitFullscreen();
            }
        }

        function handleInteractionStart(tC){if(!tC||isDrawing||isAnimating)return;const x=parseInt(tC.dataset.x,10),y=parseInt(tC.dataset.y,10);if(x===startCoords.x&&y===startCoords.y){isDrawing=true;userPath=[{x,y}];redrawUserPath()}}
        function handleInteractionMove(tC){if(!isDrawing||!tC||isAnimating)return;const x=parseInt(tC.dataset.x,10),y=parseInt(tC.dataset.y,10);const lP=userPath[userPath.length-1];if(x===lP.x&&y===lP.y)return;if(userPath.length>1&&userPath[userPath.length-2].x===x&&userPath[userPath.length-2].y===y){userPath.pop()}else{const cD=currentGridState[lP.y][lP.x];const dX=x-lP.x,dY=y-lP.y;if(Math.abs(dX)+Math.abs(dY)===1){let wI=dY===-1?0:dX===1?1:dY===1?2:3;if(!cD.walls[wI])userPath.push({x,y})}}redrawUserPath();if(x===endCoords.x&&y===endCoords.y)handleInteractionEnd()}
        function handleInteractionEnd(){if(!isDrawing)return;isDrawing=false;const lP=userPath[userPath.length-1];if(lP&&lP.x===endCoords.x&&lP.y===endCoords.y){handlePuzzleCompletion(Date.now() - startTime);}}
        function handleKeyDown(e){const activeEl = document.activeElement; if (activeEl && activeEl.tagName === 'INPUT') return; if(e.key.toLowerCase()==='f'){toggleFullScreen(); return;} if(!['ArrowUp','ArrowDown','ArrowLeft','ArrowRight', 'r', 'R'].includes(e.key)||isDrawing||isAnimating)return;e.preventDefault();if(e.key.toLowerCase()==='r'){revealSolution();return}if(userPath.length===0) return;const lP=userPath[userPath.length-1];let tP,wI=-1;switch(e.key){case'ArrowUp':tP={x:lP.x,y:lP.y-1};wI=0;break;case'ArrowDown':tP={x:lP.x,y:lP.y+1};wI=2;break;case'ArrowLeft':tP={x:lP.x-1,y:lP.y};wI=3;break;case'ArrowRight':tP={x:lP.x+1,y:lP.y};wI=1;break}if(userPath.length>1&&tP.x===userPath[userPath.length-2].x&&tP.y===userPath[userPath.length-2].y){userPath.pop()}else{if(tP.x>=0&&tP.x<gridSize&&tP.y>=0&&tP.y<gridSize){const cD=currentGridState[lP.y][lP.x];if(!cD.walls[wI]){userPath.push(tP)}}}redrawUserPath();const nLP=userPath[userPath.length-1];if(nLP.x===endCoords.x&&nLP.y===endCoords.y){handlePuzzleCompletion(Date.now()-startTime);}}

        function formatTime(ms){const s=Math.floor(ms/1000);return`${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`}
        function handlePuzzleCompletion(elapsedTime) { const bestTime = localStorage.getItem(puzzleConfigKey); let isNewBest = false; if (bestTime === null || elapsedTime < parseInt(bestTime, 10)) { localStorage.setItem(puzzleConfigKey, elapsedTime); isNewBest = true; } document.getElementById('your-time').textContent = `Your time: ${formatTime(elapsedTime)}`; document.getElementById('best-time').textContent = `Best time: ${formatTime(localStorage.getItem(puzzleConfigKey))}`; document.getElementById('new-best-time').textContent = isNewBest ? 'New Best Time!' : ''; ui.completionModal.classList.add('visible'); ui.revealBtn.disabled = true; document.querySelectorAll('#grid div.user-path').forEach(c => { c.classList.remove('user-path'); c.classList.add('solved-path'); }); }
        function hideCompletionModal(){ui.completionModal.classList.remove('visible')}

        const themeToggleBtn=document.getElementById('theme-toggle-btn');function setTheme(t){document.body.classList.toggle('dark-mode',t==='dark');localStorage.setItem('theme',t)}themeToggleBtn.addEventListener('click',()=>setTheme(document.body.classList.contains('dark-mode')?'light':'dark'));const savedTheme=localStorage.getItem('theme'),prefersDark=window.matchMedia('(prefers-color-scheme: dark)').matches;setTheme(savedTheme||(prefersDark?'dark':'light'));
        
        document.addEventListener('DOMContentLoaded', () => {
            // Maze Interaction
            ui.grid.addEventListener('mousedown',e=>{if(e.button===0)handleInteractionStart(e.target.closest('div[data-x]'))});
            ui.grid.addEventListener('mouseover',e=>handleInteractionMove(e.target.closest('div[data-x]')));
            document.addEventListener('mouseup',e=>{if(e.button===0)handleInteractionEnd()});
            ui.grid.addEventListener('touchstart',e=>{e.preventDefault();const t=e.touches[0];handleInteractionStart(document.elementFromPoint(t.clientX,t.clientY)?.closest('div[data-x]'))},{passive:false});
            ui.grid.addEventListener('touchmove',e=>{e.preventDefault();const t=e.touches[0];handleInteractionMove(document.elementFromPoint(t.clientX,t.clientY)?.closest('div[data-x]'))},{passive:false});
            ui.grid.addEventListener('touchend',handleInteractionEnd);
            ui.grid.addEventListener('touchcancel',handleInteractionEnd);
            document.addEventListener('keydown',handleKeyDown);
            
            // Seed buttons
            ui.playSeedBtn.addEventListener('click', () => { if (ui.seedInput.value.trim() !== '') { triggerGeneratePuzzle(); }});
            ui.randomSeedBtn.addEventListener('click', () => { ui.seedInput.value = Date.now().toString(36); triggerGeneratePuzzle(); });

            // Main Controls
            ui.newRandomMazeBtn.addEventListener('click', () => { ui.seedInput.value = ''; triggerGeneratePuzzle(); });
            ui.customMazeBtn.addEventListener('click', () => setUIView('custom'));
            ui.revealBtn.addEventListener('click', revealSolution);
            ui.downloadPdfBtn.addEventListener('click', downloadPdf);
            ui.makeBookBtn.addEventListener('click', () => setUIView('book'));
            ui.fullscreenBtn.addEventListener('click', toggleFullScreen);
            
            // Custom Maze Controls
            ui.createPuzzleBtn.addEventListener('click', () => { ui.seedInput.value = ''; triggerGeneratePuzzle(); setUIView('default'); });
            ui.cancelCustomBtn.addEventListener('click', () => setUIView('default'));

            // Book Controls
            ui.createBookBtn.addEventListener('click', downloadBook);
            ui.cancelBookOptionsBtn.addEventListener('click', () => setUIView('default'));

            // Modal Controls
            ui.playAgainBtn.addEventListener('click', () => { hideCompletionModal(); triggerGeneratePuzzle(); });

            // Event Listeners
            document.addEventListener('fullscreenchange', () => {
                if(currentGridState.length > 0) {
                     clearTimeout(debounceTimeout);
                     debounceTimeout = setTimeout(() => updateGridDisplay(true), 100);
                }
            });
            window.addEventListener('resize',()=>{if(currentGridState.length>0 && !document.fullscreenElement){clearTimeout(debounceTimeout);debounceTimeout=setTimeout(()=>updateGridDisplay(true),100)}});

            // Initial Setup
            ui.seedInput.value = ''; // Clear seed on load to ensure a new maze on refresh
            triggerGeneratePuzzle();
        });
    </script>
</body>
</html>