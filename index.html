<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Generator v0.5</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        /* CSS Variables for Theming */
        :root {
            --color-background: #f8f9fa;
            --color-container-bg: #f8f9fa;
            --color-text-primary: #333;
            --color-text-secondary: #6c757d;
            --color-heading: #343a40;
            --color-grid-lines: #adb5bd; /* Will be used for maze walls */
            --color-grid-cell-bg: #fff;
            --color-button-disabled-bg: #6c757d;
            --color-spinner-track: #f3f3f3;
            --color-modal-bg: rgba(0, 0, 0, 0.6);
            --color-modal-content-bg: white;
            --color-box-shadow: rgba(0,0,0,0.1);
            --color-box-shadow-hover: rgba(0,0,0,0.15);

            /* Brand & Maze Colors */
            --color-primary: #007bff;
            --color-success: #28a745; /* Start Point & Solution */
            --color-danger: #dc3545;  /* End Point */
            --color-warning: #fd7e14;
            --color-info: #6f42c1;
            --color-pink: #d63384;
            --color-revealed-bg: rgba(40, 167, 69, 0.3); /* Solution path */
            --color-user-path-bg: rgba(0, 123, 255, 0.3); /* User's drawing path */
            --color-start-bg: var(--color-success);
            --color-end-bg: var(--color-danger);
            --color-cursor-shadow: rgba(0, 123, 255, 0.7);
        }

        body.dark-mode {
            --color-background: #121212;
            --color-container-bg: #1e1e1e;
            --color-text-primary: #e0e0e0;
            --color-text-secondary: #888;
            --color-heading: #f1f1f1;
            --color-grid-lines: #666; /* Maze walls in dark mode */
            --color-grid-cell-bg: #2a2a2a;
            --color-button-disabled-bg: #555;
            --color-spinner-track: #444;
            --color-modal-bg: rgba(0, 0, 0, 0.8);
            --color-modal-content-bg: #2c2c2c;
            --color-box-shadow: rgba(0,0,0,0.3);
            --color-box-shadow-hover: rgba(0,0,0,0.4);
            --color-revealed-bg: rgba(40, 167, 69, 0.4);
            --color-user-path-bg: rgba(0, 123, 255, 0.4);
            --color-cursor-shadow: rgba(50, 150, 255, 0.7);
        }

        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; font-size: 16px; color: var(--color-text-primary); background-color: var(--color-background); padding: 20px; margin: 0; display: flex; justify-content: center; align-items: flex-start; min-height: 100vh; transition: background-color 0.3s, color 0.3s; }
        .container { width: 100%; max-width: 900px; margin: 0 auto; }
        
        .main-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        .main-header h1 { flex-grow: 1; margin: 0; padding: 0 10px; text-align: center; }
        .header-spacer { width: 44px; height: 44px; flex-shrink: 0; }
        
        #puzzle-container { display: flex; margin-top: 20px; justify-content: center; }
        #grid-wrapper { position: relative; }
        #grid { display: grid; background-color: transparent; border: 1px solid var(--color-grid-lines); font-family: "Courier New", Courier, monospace; font-weight: bold; cursor: pointer; }
        #grid div { text-align: center; background-color: var(--color-grid-cell-bg); color: var(--color-text-primary); user-select: none; transition: background-color 0.2s; position: relative; border-color: var(--color-grid-lines); box-sizing: border-box; }
        /* Wall styles */
        #grid div.wall-top { border-top: 1px solid var(--color-grid-lines); }
        #grid div.wall-right { border-right: 1px solid var(--color-grid-lines); }
        #grid div.wall-bottom { border-bottom: 1px solid var(--color-grid-lines); }
        #grid div.wall-left { border-left: 1px solid var(--color-grid-lines); }
        /* Path and special cell styles */
        #grid div.start-cell { background-color: var(--color-start-bg); }
        #grid div.end-cell { background-color: var(--color-end-bg); }
        #grid div.solution-path { background-color: var(--color-revealed-bg); }
        #grid div.user-path { background-color: var(--color-user-path-bg); }
        #grid div.keyboard-cursor { box-shadow: inset 0 0 0 3px var(--color-cursor-shadow); }

        body.dark-mode .loader { background-color: var(--color-background); }
        .loader { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--color-container-bg); display: flex; justify-content: center; align-items: center; flex-direction: column; gap: 15px; z-index: 10; font-size: 1.1em; color: var(--color-text-secondary); border-radius: 4px; }
        .loader.hidden { opacity: 0; pointer-events: none; }
        #loader-time { font-size: 0.9em; font-style: italic; color: var(--color-text-secondary); }
        .spinner { border: 4px solid var(--color-spinner-track); border-top: 4px solid var(--color-primary); border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        #instructions-container { width: fit-content; margin: 20px auto 0 auto; text-align: center; }
        #instructions-container h3 { margin-top: 0; color: var(--color-heading); }
        #instructions-list { list-style-position: inside; padding: 0; margin: 0 auto; display: inline-block; text-align: left; }
        #instructions-list li { padding: 4px 0; font-size: 0.95em; color: var(--color-text-primary); }

        .controls-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; max-width: 415px; margin: 25px auto 0 auto; }
        .global-options-container { display: grid; grid-template-columns: 1fr 1fr; gap: 15px 25px; max-width: 500px; margin: 25px auto -10px auto; align-items: center; }
        .option-group { display: flex; align-items: center; justify-content: space-between; gap: 10px; }
        .option-group label { font-weight: bold; }
        .option-group select, .option-group input { flex-grow: 1; min-width: 80px; padding: 6px; }

        button { padding: 12px 20px; font-size: 1em; font-weight: bold; cursor: pointer; color: white; border: none; border-radius: 5px; transition: all 0.2s; box-shadow: 0 2px 4px var(--color-box-shadow); width: 100%; box-sizing: border-box; }
        button:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 4px 8px var(--color-box-shadow-hover); }
        button:disabled { background-color: var(--color-button-disabled-bg); cursor: not-allowed; opacity: 0.7; }
        #generate-btn { background-color: var(--color-primary); }
        #reveal-btn { background-color: var(--color-success); }
        #download-pdf-btn { background-color: var(--color-pink); }
        #make-book-btn { background-color: var(--color-danger); }
        #create-book-btn { background-color: var(--color-danger); }
        #cancel-btn, #cancel-book-options-btn { background-color: var(--color-text-secondary); }
        #cancel-btn { min-width: 120px; width: auto; }
        
        #generate-book-controls { display: none; }
        .book-options-grid { display: grid; grid-template-columns: auto 1fr; justify-content: center; align-items: center; gap: 10px 15px; margin: 15px auto 0 auto; max-width: 415px; }
        .book-options-grid label { text-align: right; }
        #book-checkbox-options { display: flex; gap: 20px; align-items: center; justify-content: flex-start; }
        #book-checkbox-options label { user-select: none; cursor: pointer; }
        #status-container { text-align: center; margin-top: 15px; font-style: italic; min-height: 20px; color: var(--color-text-secondary); }
        #version-info { text-align: center; margin-top: 20px; font-size: 0.8em; color: var(--color-grid-lines); }
        
        #completion-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--color-modal-bg); display: flex; justify-content: center; align-items: center; z-index: 20; opacity: 0; pointer-events: none; transition: opacity 0.3s ease-in-out; }
        #completion-modal.visible { opacity: 1; pointer-events: auto; }
        .modal-content { background-color: var(--color-modal-content-bg); padding: 40px; border-radius: 10px; text-align: center; box-shadow: 0 5px 15px var(--color-box-shadow); transform: scale(0.9); transition: transform 0.3s ease-in-out; }
        #completion-modal.visible .modal-content { transform: scale(1); }
        .modal-content h2 { font-size: 2.5em; margin-top: 0; margin-bottom: 20px; color: var(--color-success); }
        .modal-content button { min-width: 150px; background-color: var(--color-primary); }
        #completion-details { margin-bottom: 25px; font-size: 1.1em; color: var(--color-text-primary); }
        #completion-details p { margin: 5px 0; }
        #new-best-time { color: var(--color-warning); font-weight: bold; }

        #grid-wrapper, #instructions-container { visibility: hidden; }

        #theme-toggle-btn { background: none; border: 2px solid var(--color-text-secondary); color: var(--color-text-secondary); width: 44px; height: 44px; padding: 0; border-radius: 50%; display: flex; justify-content: center; align-items: center; overflow: hidden; box-shadow: none; flex-shrink: 0; }
        #theme-toggle-btn:hover { border-color: var(--color-text-primary); color: var(--color-text-primary); transform: none; box-shadow: none; }
        #theme-toggle-btn svg { width: 24px; height: 24px; fill: currentColor; transition: transform 0.3s ease-in-out; }
        .icon-sun { display: none; }
        .icon-moon { display: none; }

        body.dark-mode .icon-sun { display: block; }
        body:not(.dark-mode) .icon-moon { display: block; }

        @media print { @page { size: A4; margin: 0.5in; } body { background-color: #fff; font-size: 12pt; margin: 0; padding: 0; } .container { width: 100%; margin: 0; padding: 0; box-shadow: none; } .main-header, .global-options-container, .controls-grid, #generate-book-controls, #status-container, #version-info { display: none; } #grid-wrapper { border: 2px solid #333; } #grid { border: none; } #instructions-container { margin-top: 15px; } }
    
        @media (max-width: 768px) {
            .book-options-grid { grid-template-columns: 1fr; }
            .book-options-grid label { text-align: left; margin-left: 5px; }
            .global-options-container { grid-template-columns: 1fr; }
        }

        @media (max-width: 480px) {
            .main-header h1 { font-size: 1.5em; }
            #book-checkbox-options { flex-direction: column; align-items: flex-start; gap: 12px; }
            .modal-content h2 { font-size: 2em; }
        }
    </style>
    <style id="dynamic-grid-styles"></style>
</head>
<body>
    <div class="container">
        <header class="main-header">
            <div class="header-spacer"></div>
            <h1>Maze Generator</h1>
            <button id="theme-toggle-btn" title="Toggle theme">
                <svg class="icon-sun" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zM2 13h2c.55 0 1-.45 1-1s-.45-1-1-1H2c-.55 0-1 .45-1 1s.45 1 1 1zm18 0h2c.55 0 1-.45 1-1s-.45-1-1-1h-2c-.55 0-1 .45-1 1s.45 1 1 1zM11 2v2c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1s-1 .45-1 1zm0 18v2c0 .55.45 1 1 1s1-.45 1-1v-2c0-.55-.45-1-1-1s-1 .45-1 1zM5.64 5.64c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41-.39-.39-1.02-.39-1.41 0-.39.39-.39 1.02 0 1.41zm12.73 12.73c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41-.39-.39-1.02-.39-1.41 0-.39.39-.39 1.02 0 1.41zM5.64 18.36c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41-.39-.39-1.02-.39-1.41 0zM18.36 5.64c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41-.39-.38-1.03-.38-1.41 0z"/></svg>
                <svg class="icon-moon" xmlns="http://www.w3.org/2000/svg" enable-background="new 0 0 24 24" viewBox="0 0 24 24"><path d="M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.11-1.36c-0.98,1.37-2.58,2.26-4.39,2.26 c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.39C12.92,3.04,12.46,3,12,3z"/></svg>
            </button>
        </header>

        <div id="puzzle-container">
            <div id="grid-wrapper">
                <div id="grid"></div>
                <div id="loader" class="loader">
                    <div class="spinner"></div>
                    <span id="loader-text"></span>
                    <span id="loader-time"></span>
                    <button id="cancel-btn" onclick="cancelBookGeneration()">Cancel</button>
                </div>
            </div>
        </div>
        <div id="instructions-container">
            <h3>Instructions</h3>
            <ul id="instructions-list">
                <li>Click the start (green), then use the Arrow Keys to move.</li>
                <li>Or, click and drag from the green square to the red square.</li>
            </ul>
        </div>
        
        <div class="global-options-container" id="global-options-container">
            <div class="option-group">
                <label for="grid-size-select">Grid Size:</label>
                <select id="grid-size-select" onchange="triggerGeneratePuzzle()">
                    <option value="15">15x15</option>
                    <option value="20" selected>20x20</option>
                    <option value="25">25x25</option>
                    <option value="50">50x50</option>
                    <option value="75">75x75</option>
                    <option value="100">100x100</option>
                </select>
            </div>
            <div class="option-group">
                <label for="maze-type-select">Maze Type:</label>
                <select id="maze-type-select" onchange="triggerGeneratePuzzle()">
                    <option value="backtracker" selected>DFS Backtracker</option>
                    <option value="prim">Prim's Algorithm</option>
                    <option value="binary">Binary Tree</option>
                </select>
            </div>
            <div class="option-group">
                <label for="seed-input">Seed:</label>
                <input type="text" id="seed-input" oninput="triggerGeneratePuzzle(true)" placeholder="Any text for repeatable maze">
            </div>
        </div>

        <div class="controls-grid" id="main-controls">
            <button id="generate-btn" onclick="triggerGeneratePuzzle()">New Maze</button>
            <button id="reveal-btn" onclick="revealSolution()">Reveal Solution</button>
            <button id="download-pdf-btn" onclick="downloadPdf()">Download as PDF</button>
            <button id="make-book-btn" onclick="showBookOptions()">Make Book</button>
        </div>

        <div id="generate-book-controls">
            <h3>Make a Book</h3>
            <div class="book-options-grid">
                <label for="book-title-input">Book Title:</label>
                <input type="text" id="book-title-input" placeholder="e.g., My Awesome Maze Book">
                
                <label for="book-subtitle-input">Subtitle:</label>
                <input type="text" id="book-subtitle-input" placeholder="e.g., By Alex Doe">

                <label for="puzzle-count-input">Mazes:</label>
                <input type="number" id="puzzle-count-input" value="10" min="1" max="100" style="width: 70px;">
                
                <label>Options:</label>
                <div id="book-checkbox-options">
                    <label for="answer-key-checkbox"><input type="checkbox" id="answer-key-checkbox" checked> Maze Solutions</label>
                    <label for="page-numbers-checkbox"><input type="checkbox" id="page-numbers-checkbox" checked> Page Numbers</label>
                </div>
            </div>
            <div class="controls-grid">
                <button id="create-book-btn" onclick="downloadBook()">Create Book</button>
                <button id="cancel-book-options-btn" onclick="resetBookUI()">Cancel</button>
            </div>
        </div>


        <div id="status-container"><p id="source-status"></p></div>
        <div id="version-info">v0.5</div>
    </div>

    <div id="completion-modal" onclick="hideCompletionModal()">
        <div class="modal-content">
            <h2>You Solved It!</h2>
            <div id="completion-details">
                <p id="your-time"></p>
                <p id="best-time"></p>
                <p id="new-best-time"></p>
            </div>
            <button onclick="triggerGeneratePuzzle()">Play Again?</button>
        </div>
    </div>
    
    <script>
        let gridSize = 20;
        let currentGridState = [], solutionPath = [];
        let isGeneratingBook = false;
        let debounceTimeout;

        let startTime;
        let puzzleConfigKey;
        let rng; // The pseudo-random number generator function

        let isDrawing = false;
        let userPath = [];
        let startCoords, endCoords;

        const gridElement = document.getElementById('grid'),
              revealBtn = document.getElementById('reveal-btn'),
              statusElement = document.getElementById('source-status'),
              loader = document.getElementById('loader'),
              loaderText = document.getElementById('loader-text'),
              gridSizeSelect = document.getElementById('grid-size-select'),
              mazeTypeSelect = document.getElementById('maze-type-select'),
              seedInput = document.getElementById('seed-input'),
              mainControls = document.getElementById('main-controls'),
              generateBookControls = document.getElementById('generate-book-controls'),
              cancelBtn = document.getElementById('cancel-btn'),
              globalOptionsContainer = document.getElementById('global-options-container'),
              gridWrapper = document.getElementById('grid-wrapper'),
              instructionsContainer = document.getElementById('instructions-container'),
              dynamicGridStyles = document.getElementById('dynamic-grid-styles'),
              completionModal = document.getElementById('completion-modal');
        
        // --- SEEDED RNG ---
        function cyrb128(str) {
            let h1 = 1779033703, h2 = 3144134277, h3 = 1013904242, h4 = 2773480762;
            for (let i = 0, k; i < str.length; i++) {
                k = str.charCodeAt(i);
                h1 = h2 ^ Math.imul(h1 ^ k, 597399067);
                h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);
                h3 = h4 ^ Math.imul(h3 ^ k, 951274213);
                h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);
            }
            h1 = Math.imul(h3 ^ (h1 >>> 18), 597399067);
            h2 = Math.imul(h4 ^ (h2 >>> 22), 2869860233);
            h3 = Math.imul(h1 ^ (h3 >>> 17), 951274213);
            h4 = Math.imul(h2 ^ (h4 >>> 19), 2716044179);
            return (h1^h2^h3^h4)>>>0;
        }

        function mulberry32(a) {
            return function() {
              var t = a += 0x6D2B79F5;
              t = Math.imul(t ^ t >>> 15, t | 1);
              t ^= t + Math.imul(t ^ t >>> 7, t | 61);
              return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }
        
        // --- MAZE GENERATION ---

        function triggerGeneratePuzzle(isDebounced = false) {
            clearTimeout(debounceTimeout);
            debounceTimeout = setTimeout(() => generatePuzzle(), isDebounced ? 400 : 0);
        }

        async function generatePuzzle(isForBook = false) {
            gridSize = parseInt(gridSizeSelect.value, 10);
            const mazeType = mazeTypeSelect.value;
            let seed = seedInput.value.trim();
            if (seed === '') { seed = Date.now().toString(); }

            // Initialize the RNG for this generation
            rng = mulberry32(cyrb128(seed));

            const loaderMessage = gridSize >= 50 ? "Generating large maze..." : "Generating Maze...";
            if (!isForBook) {
                setUiLoading(true, loaderMessage);
                hideCompletionModal();
            }
            
            userPath = [];
            solutionPath = [];
            startTime = null;
            revealBtn.disabled = false;
            
            await new Promise(resolve => setTimeout(resolve, 30));

            try {
                let mazeGrid;
                switch(mazeType) {
                    case 'prim':
                        mazeGrid = generateMazePrim(gridSize, gridSize);
                        break;
                    case 'binary':
                        mazeGrid = generateMazeBinaryTree(gridSize, gridSize);
                        break;
                    case 'backtracker':
                    default:
                         mazeGrid = generateMazeRecursiveBacktracker(gridSize, gridSize);
                        break;
                }
                
                startCoords = { x: 0, y: 0 };
                endCoords = { x: gridSize - 1, y: gridSize - 1 };
                
                const path = findSolutionPath(mazeGrid, startCoords, endCoords);
                userPath.push(startCoords);

                if (!isForBook) {
                    currentGridState = mazeGrid;
                    solutionPath = path;
                    puzzleConfigKey = `${gridSize}-${mazeType}-${seed}`;
                    const typeName = mazeTypeSelect.options[mazeTypeSelect.selectedIndex].text;
                    statusElement.textContent = `Type: ${typeName}`;
                    updateGridDisplay();
                    gridWrapper.style.visibility = 'visible';
                    instructionsContainer.style.visibility = 'visible';
                    startTime = Date.now();
                }

                return { grid: mazeGrid, solution: path, title: `Maze ${gridSize}x${gridSize}` };

            } catch (error) {
                statusElement.textContent = `Error: ${error.message}`;
                console.error(error);
                return null;
            } finally {
                if (!isForBook) {
                    setUiLoading(false);
                }
            }
        }

        function createEmptyGrid(width, height) {
            return Array(height).fill(null).map((_, y) => Array(width).fill(null).map((_, x) => ({ x, y, walls: [true, true, true, true], visited: false })));
        }

        // ALGORITHM 1: Recursive Backtracker (DFS)
        function generateMazeRecursiveBacktracker(width, height) {
            const grid = createEmptyGrid(width, height);
            const stack = [grid[0][0]];
            grid[0][0].visited = true;

            while (stack.length > 0) {
                const current = stack.pop();
                const neighbors = getNeighbors(current, grid, false);
                if (neighbors.length > 0) {
                    stack.push(current);
                    const neighbor = neighbors[Math.floor(rng() * neighbors.length)];
                    removeWall(current, neighbor);
                    neighbor.visited = true;
                    stack.push(neighbor);
                }
            }
            return grid;
        }

        // ALGORITHM 2: Prim's Algorithm
        function generateMazePrim(width, height) {
            const grid = createEmptyGrid(width, height);
            const frontier = [];
            
            const startX = Math.floor(rng() * width);
            const startY = Math.floor(rng() * height);
            grid[startY][startX].visited = true;
            
            getNeighbors(grid[startY][startX], grid, true).forEach(n => frontier.push(n));

            while(frontier.length > 0) {
                const frontierIndex = Math.floor(rng() * frontier.length);
                const current = frontier[frontierIndex];
                frontier.splice(frontierIndex, 1);

                const inNeighbors = getNeighbors(current, grid, true).filter(n => n.visited);
                if(inNeighbors.length > 0) {
                    const neighbor = inNeighbors[Math.floor(rng() * inNeighbors.length)];
                    removeWall(current, neighbor);
                    current.visited = true;
                    getNeighbors(current, grid, true).filter(n => !n.visited).forEach(n => {
                        if(!frontier.includes(n)) frontier.push(n);
                    });
                }
            }
            return grid;
        }

        // ALGORITHM 3: Binary Tree
        function generateMazeBinaryTree(width, height) {
            const grid = createEmptyGrid(width, height);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const cell = grid[y][x];
                    const neighbors = [];
                    if (y > 0) neighbors.push(grid[y - 1][x]); // North
                    if (x > 0) neighbors.push(grid[y][x - 1]); // West
                    
                    if(neighbors.length > 0) {
                        const neighbor = neighbors[Math.floor(rng() * neighbors.length)];
                        removeWall(cell, neighbor);
                    }
                }
            }
            return grid;
        }

        function getNeighbors(cell, grid, all) {
            const { x, y } = cell;
            const neighbors = [];
            const directions = [{x:0, y:-1}, {x:1, y:0}, {x:0, y:1}, {x:-1, y:0}]; // N, E, S, W
            for (const dir of directions) {
                const nX = x + dir.x, nY = y + dir.y;
                if (nX >= 0 && nX < grid[0].length && nY >= 0 && nY < grid.length) {
                   const neighbor = grid[nY][nX];
                   if(all || !neighbor.visited) neighbors.push(neighbor);
                }
            }
            return neighbors;
        }

        function removeWall(a, b) {
            const dX = a.x - b.x, dY = a.y - b.y;
            if (dX === 1) { a.walls[3] = false; b.walls[1] = false; } 
            else if (dX === -1) { a.walls[1] = false; b.walls[3] = false; }
            if (dY === 1) { a.walls[0] = false; b.walls[2] = false; } 
            else if (dY === -1) { a.walls[2] = false; b.walls[0] = false; }
        }

        function findSolutionPath(grid, start, end) {
            const queue = [[start]];
            const visited = new Set([`${start.x},${start.y}`]);
            while (queue.length > 0) {
                const path = queue.shift();
                const { x, y } = path[path.length - 1];
                if (x === end.x && y === end.y) return path;
                const cell = grid[y][x];
                const directions = [{x:0, y:-1}, {x:1, y:0}, {x:0, y:1}, {x:-1, y:0}];
                for (let i = 0; i < directions.length; i++) {
                    if (!cell.walls[i]) {
                        const nX = x + directions[i].x, nY = y + directions[i].y;
                        const key = `${nX},${nY}`;
                        if (!visited.has(key)) {
                            visited.add(key);
                            queue.push([...path, {x: nX, y: nY}]);
                        }
                    }
                }
            }
            return [];
        }

        // --- UI & RENDERING ---

        function setUiLoading(isLoading, message = '') { 
            document.querySelectorAll('button').forEach(btn => btn.disabled = isLoading); 
            loader.classList.toggle('hidden', !isLoading); 
            loaderText.textContent = message;
            cancelBtn.style.display = 'none'; // Hide by default
        }

        function updateGridDisplay() {
            gridElement.innerHTML = '';
            const puzzleContainerWidth = Math.min(document.getElementById('puzzle-container').clientWidth, 800);
            let cellSize = Math.floor(puzzleContainerWidth / gridSize);
            cellSize = Math.max(2, cellSize);
            gridElement.style.gridTemplateColumns = `repeat(${gridSize}, ${cellSize}px)`;
            gridElement.style.gridTemplateRows = `repeat(${gridSize}, ${cellSize}px)`;
            
            const wallWidth = Math.max(1, Math.floor(cellSize / 12));
            dynamicGridStyles.innerHTML = `
                #grid div.wall-top { border-top-width: ${wallWidth}px; border-top-style: solid; }
                #grid div.wall-right { border-right-width: ${wallWidth}px; border-right-style: solid; }
                #grid div.wall-bottom { border-bottom-width: ${wallWidth}px; border-bottom-style: solid; }
                #grid div.wall-left { border-left-width: ${wallWidth}px; border-left-style: solid; }
                #grid div.keyboard-cursor { box-shadow: inset 0 0 0 ${Math.max(2, wallWidth + 1)}px var(--color-cursor-shadow); }
            `;

            for (let y = 0; y < gridSize; y++) { 
                for (let x = 0; x < gridSize; x++) { 
                    const cell = document.createElement('div'); 
                    cell.dataset.x = x; cell.dataset.y = y;
                    const cellData = currentGridState[y][x];
                    if(cellData.walls[0]) cell.classList.add('wall-top');
                    if(cellData.walls[1]) cell.classList.add('wall-right');
                    if(cellData.walls[2]) cell.classList.add('wall-bottom');
                    if(cellData.walls[3]) cell.classList.add('wall-left');
                    if (x === startCoords.x && y === startCoords.y) cell.classList.add('start-cell');
                    if (x === endCoords.x && y === endCoords.y) cell.classList.add('end-cell');
                    gridElement.appendChild(cell); 
                } 
            }
            redrawUserPath();
        }

        function redrawUserPath() {
            document.querySelectorAll('#grid div.user-path, #grid div.keyboard-cursor').forEach(c => {
                c.classList.remove('user-path', 'keyboard-cursor');
            });
            userPath.forEach(pos => {
                const cell = gridElement.querySelector(`[data-x='${pos.x}'][data-y='${pos.y}']`);
                if (cell) cell.classList.add('user-path');
            });
            if (userPath.length > 0) {
                const lastPos = userPath[userPath.length - 1];
                const cursorCell = gridElement.querySelector(`[data-x='${lastPos.x}'][data-y='${lastPos.y}']`);
                if(cursorCell) cursorCell.classList.add('keyboard-cursor');
            }
        }
        
        function revealSolution() { 
            if (solutionPath.length === 0) return;
            solutionPath.forEach(pos => {
                 const cell = gridElement.querySelector(`[data-x='${pos.x}'][data-y='${pos.y}']`);
                 if(cell) cell.classList.add('solution-path');
            });
            revealBtn.disabled = true;
        }
        
        // --- PDF & BOOK GENERATION ---

        function showBookOptions() { mainControls.style.display = 'none'; generateBookControls.style.display = 'block'; globalOptionsContainer.style.display = 'none';}
        function resetBookUI() { mainControls.style.display = 'grid'; generateBookControls.style.display = 'grid'; globalOptionsContainer.style.display = 'grid';}

        function downloadPdf() {
            if (currentGridState.length === 0) { alert("Please generate a maze first."); return; }
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
            drawMazeOnPdfPage(doc, { grid: currentGridState, solution: solutionPath, title: 'Maze' }, false, null, false);
            doc.save(`Maze-${gridSize}x${gridSize}-${mazeTypeSelect.value}.pdf`);
        }

        async function downloadBook() {
            const puzzleCount = parseInt(document.getElementById('puzzle-count-input').value, 10);
            if (isNaN(puzzleCount) || puzzleCount < 1 || puzzleCount > 100) { alert("Please enter a number between 1 and 100."); return; }
            const includeAnswerKey = document.getElementById('answer-key-checkbox').checked;
            const includePageNumbers = document.getElementById('page-numbers-checkbox').checked;
            const bookTitle = document.getElementById('book-title-input').value.trim();
            const bookSubtitle = document.getElementById('book-subtitle-input').value.trim();
            
            gridElement.innerHTML = ''; instructionsContainer.style.visibility = 'hidden';
            isGeneratingBook = true;
            setUiLoading(true, "Preparing Book...");
            loader.scrollIntoView({ behavior: 'smooth', block: 'center' });
            cancelBtn.style.display = 'block'; cancelBtn.disabled = false;
            
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
            doc.deletePage(1);
            const allPuzzlesData = [];
            
            try {
                if (bookTitle) {
                    doc.addPage();
                    const pageW = doc.internal.pageSize.getWidth(), pageH = doc.internal.pageSize.getHeight();
                    doc.setFont('helvetica', 'bold').setFontSize(30).text(bookTitle, pageW/2, pageH/2 - 10, {align: 'center'});
                    if (bookSubtitle) doc.setFont('helvetica', 'normal').setFontSize(16).text(bookSubtitle, pageW/2, pageH/2 + 5, {align: 'center'});
                }

                for (let i = 1; i <= puzzleCount; i++) {
                    if (!isGeneratingBook) { throw new Error("Cancelled"); }
                    
                    loaderText.textContent = `Generating Maze ${i} of ${puzzleCount}...`;
                    const puzzleData = await generatePuzzle(true);
                    puzzleData.title = `Maze ${i}`;
                    allPuzzlesData.push(puzzleData);
                    
                    doc.addPage();
                    drawMazeOnPdfPage(doc, puzzleData, false, i, includePageNumbers);
                }

                if (includeAnswerKey && allPuzzlesData.length > 0) {
                    loaderText.textContent = "Generating Maze Solutions...";
                    await new Promise(resolve => setTimeout(resolve, 50));
                    drawMazeSolutions(doc, allPuzzlesData);
                }

                const safeTitle = (bookTitle.replace(/[^a-zA-Z0-9]/g, '-') || `Maze-Book-${puzzleCount}-Mazes`).substring(0, 50);
                doc.save(`${safeTitle}.pdf`);
                statusElement.textContent = "Book successfully generated!";
            } catch (error) {
                if (error.message === "Cancelled") statusElement.textContent = "Book generation cancelled.";
                else statusElement.textContent = `Error: ${error.message}`;
            } finally {
                isGeneratingBook = false;
                setUiLoading(false);
                resetBookUI();
                triggerGeneratePuzzle();
            }
        }

        function cancelBookGeneration() { isGeneratingBook = false; }
        
        function drawMazeOnPdfPage(doc, puzzleData, showSolution, pageNum, includePageNumbers) {
            const { grid, solution, title } = puzzleData;
            const pageW = doc.internal.pageSize.getWidth(), pageH = doc.internal.pageSize.getHeight(), margin = 15;
            let currentY = margin;
            doc.setFont('helvetica', 'bold').setFontSize(16).text(title, pageW/2, currentY, {align:'center'});
            currentY += 15;

            const mazeSize = 180, currentGridSize = grid.length, cellSize = mazeSize / currentGridSize;
            const startX = (pageW - mazeSize) / 2, startY = currentY;

            if (showSolution) {
                doc.setFillColor(200, 255, 200);
                solution.forEach(pos => doc.rect(startX + pos.x * cellSize, startY + pos.y * cellSize, cellSize, cellSize, 'F'));
            }

            doc.setFillColor(40, 167, 69).rect(startX, startY, cellSize, cellSize, 'F');
            doc.setFillColor(220, 53, 69).rect(startX + (currentGridSize-1) * cellSize, startY + (currentGridSize-1) * cellSize, cellSize, cellSize, 'F');
            
            doc.setDrawColor(0).setLineWidth(0.5);
            for (let y = 0; y < currentGridSize; y++) {
                for (let x = 0; x < currentGridSize; x++) {
                    const cell = grid[y][x], cellX = startX + x * cellSize, cellY = startY + y * cellSize;
                    if (cell.walls[0]) doc.line(cellX, cellY, cellX + cellSize, cellY);
                    if (cell.walls[1]) doc.line(cellX + cellSize, cellY, cellX + cellSize, cellY + cellSize);
                    if (cell.walls[2]) doc.line(cellX, cellY + cellSize, cellX + cellSize, cellY + cellSize);
                    if (cell.walls[3]) doc.line(cellX, cellY, cellX, cellY + cellSize);
                }
            }
            if (includePageNumbers && pageNum) {
                doc.setFont('helvetica', 'normal').setFontSize(8).text(String(pageNum), pageW / 2, pageH - (margin / 2), { align: 'center' });
            }
        }

        function drawMazeSolutions(doc, allPuzzlesData) {
            doc.addPage();
            const pageW = doc.internal.pageSize.getWidth(), pageH = doc.internal.pageSize.getHeight(), margin = 15;
            doc.setFont('helvetica', 'bold').setFontSize(20).text("Maze Solutions", pageW/2, margin, {align:'center'});
            
            const puzzlesPerPage = 6, cols = 2, rows = 3;
            const boxW = (pageW - margin*2) / cols, boxH = (pageH - margin*2 - 10) / rows;
            
            allPuzzlesData.forEach((puzzleData, index) => {
                if (index > 0 && index % puzzlesPerPage === 0) {
                    doc.addPage();
                    doc.setFont('helvetica', 'bold').setFontSize(20).text("Maze Solutions", pageW/2, margin, {align:'center'});
                }
                const i = index % puzzlesPerPage;
                const col = i % cols, row = Math.floor(i / cols);
                const startBoxX = margin + col * boxW, startBoxY = margin + 10 + row * boxH;
                
                doc.setFont('helvetica', 'bold').setFontSize(10).text(puzzleData.title, startBoxX + boxW/2, startBoxY + 8, {align:'center'});
                
                const mazeSize = Math.min(boxW - 10, boxH - 20), currentGridSize = puzzleData.grid.length, cellSize = mazeSize / currentGridSize;
                const startX = startBoxX + (boxW - mazeSize) / 2, startY = startBoxY + 12;

                doc.setFillColor(200, 255, 200);
                puzzleData.solution.forEach(pos => doc.rect(startX + pos.x * cellSize, startY + pos.y * cellSize, cellSize, cellSize, 'F'));
                doc.setDrawColor(0).setLineWidth(0.2);
                for (let y = 0; y < currentGridSize; y++) {
                    for (let x = 0; x < currentGridSize; x++) {
                        const cell = puzzleData.grid[y][x], cellX = startX + x * cellSize, cellY = startY + y * cellSize;
                        if (cell.walls[0]) doc.line(cellX, cellY, cellX + cellSize, cellY);
                        if (cell.walls[1]) doc.line(cellX + cellSize, cellY, cellX + cellSize, cellY + cellSize);
                        if (cell.walls[2]) doc.line(cellX, cellY + cellSize, cellX + cellSize, cellY + cellSize);
                        if (cell.walls[3]) doc.line(cellX, cellY, cellX, cellY + cellSize);
                    }
                }
            });
        }
        
        // --- INTERACTIVE MAZE LOGIC ---

        function handleInteractionStart(targetCell) {
            if (!targetCell || isDrawing) return;
            const x = parseInt(targetCell.dataset.x, 10), y = parseInt(targetCell.dataset.y, 10);
            if (x === startCoords.x && y === startCoords.y) {
                isDrawing = true; 
                userPath = [{x, y}]; 
                redrawUserPath();
            }
        }
        
        function handleInteractionMove(targetCell) {
            if (!isDrawing || !targetCell) return;
            
            const x = parseInt(targetCell.dataset.x, 10);
            const y = parseInt(targetCell.dataset.y, 10);
            const lastPos = userPath[userPath.length - 1];
            if (x === lastPos.x && y === lastPos.y) return;

            if (userPath.length > 1 && userPath[userPath.length - 2].x === x && userPath[userPath.length - 2].y === y) {
                userPath.pop();
            } else {
                const currentCellData = currentGridState[lastPos.y][lastPos.x];
                const dX = x - lastPos.x, dY = y - lastPos.y;
                if (Math.abs(dX) + Math.abs(dY) === 1) {
                    let wallIndex = dY === -1 ? 0 : dX === 1 ? 1 : dY === 1 ? 2 : 3;
                    if (!currentCellData.walls[wallIndex]) userPath.push({x, y});
                }
            }
            redrawUserPath();
            if (x === endCoords.x && y === endCoords.y) handleInteractionEnd();
        }

        function handleInteractionEnd() {
            if (!isDrawing) return;
            isDrawing = false;
            const lastPos = userPath[userPath.length - 1];
            if (lastPos && lastPos.x === endCoords.x && lastPos.y === endCoords.y) {
                handlePuzzleCompletion(Date.now() - startTime);
            }
        }

        function handleKeyDown(e) {
            if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) return;
            if (userPath.length === 0 || isDrawing) return;

            e.preventDefault();
            const lastPos = userPath[userPath.length - 1];
            let targetPos;
            let wallIndex = -1;

            switch(e.key) {
                case 'ArrowUp': targetPos = {x: lastPos.x, y: lastPos.y - 1}; wallIndex = 0; break;
                case 'ArrowDown': targetPos = {x: lastPos.x, y: lastPos.y + 1}; wallIndex = 2; break;
                case 'ArrowLeft': targetPos = {x: lastPos.x - 1, y: lastPos.y}; wallIndex = 3; break;
                case 'ArrowRight': targetPos = {x: lastPos.x + 1, y: lastPos.y}; wallIndex = 1; break;
            }

            if (userPath.length > 1 && targetPos.x === userPath[userPath.length - 2].x && targetPos.y === userPath[userPath.length - 2].y) {
                userPath.pop();
            } else {
                if (targetPos.x >= 0 && targetPos.x < gridSize && targetPos.y >= 0 && targetPos.y < gridSize) {
                    const currentCellData = currentGridState[lastPos.y][lastPos.x];
                    if (!currentCellData.walls[wallIndex]) {
                        userPath.push(targetPos);
                    }
                }
            }
            
            redrawUserPath();

            const newLastPos = userPath[userPath.length - 1];
            if (newLastPos.x === endCoords.x && newLastPos.y === endCoords.y) {
                handlePuzzleCompletion(Date.now() - startTime);
            }
        }

        // --- COMPLETION & TIMERS ---

        function formatTime(ms) { const s = Math.floor(ms / 1000); return `${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`; }

        function handlePuzzleCompletion(elapsedTime) {
            const bestTime = localStorage.getItem(puzzleConfigKey);
            let isNewBest = false;
            if (bestTime === null || elapsedTime < parseInt(bestTime, 10)) {
                localStorage.setItem(puzzleConfigKey, elapsedTime);
                isNewBest = true;
            }
            document.getElementById('your-time').textContent = `Your time: ${formatTime(elapsedTime)}`;
            document.getElementById('best-time').textContent = `Best time: ${formatTime(localStorage.getItem(puzzleConfigKey))}`;
            document.getElementById('new-best-time').textContent = isNewBest ? 'New Best Time!' : '';
            showCompletionModal();
        }

        function showCompletionModal() { completionModal.classList.add('visible'); revealBtn.disabled = true; }
        function hideCompletionModal() { completionModal.classList.remove('visible'); }

        // --- THEME TOGGLE ---
        const themeToggleBtn = document.getElementById('theme-toggle-btn');
        function setTheme(theme) { document.body.classList.toggle('dark-mode', theme === 'dark'); localStorage.setItem('theme', theme); }
        themeToggleBtn.addEventListener('click', () => setTheme(document.body.classList.contains('dark-mode') ? 'light' : 'dark'));
        const savedTheme = localStorage.getItem('theme'), prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        setTheme(savedTheme || (prefersDark ? 'dark' : 'light'));

        // --- EVENT LISTENERS ---
        gridElement.addEventListener('mousedown', e => { if (e.button === 0) handleInteractionStart(e.target.closest('div[data-x]')); });
        gridElement.addEventListener('mouseover', e => handleInteractionMove(e.target.closest('div[data-x]')));
        document.addEventListener('mouseup', e => { if (e.button === 0) handleInteractionEnd(); });
        gridElement.addEventListener('touchstart', e => { e.preventDefault(); const t = e.touches[0]; handleInteractionStart(document.elementFromPoint(t.clientX, t.clientY)?.closest('div[data-x]')); }, { passive: false });
        gridElement.addEventListener('touchmove', e => { e.preventDefault(); const t = e.touches[0]; handleInteractionMove(document.elementFromPoint(t.clientX, t.clientY)?.closest('div[data-x]')); }, { passive: false });
        gridElement.addEventListener('touchend', handleInteractionEnd);
        gridElement.addEventListener('touchcancel', handleInteractionEnd);
        document.addEventListener('keydown', handleKeyDown);

        window.addEventListener('load', () => triggerGeneratePuzzle());
        window.addEventListener('resize', () => { if (currentGridState.length > 0) { clearTimeout(debounceTimeout); debounceTimeout = setTimeout(updateGridDisplay, 100); } });
    </script>
</body>
</html>